; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs < %s 2>&1 | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

declare void @"some_call"(i64 addrspace(1)*)
declare i64 addrspace(1)* @"some_other_call"(i64 addrspace(1)*)

declare i32 @"personality_function"()

define i64 addrspace(1)* @test_basic(i64 addrspace(1)* %obj,
; CHECK-LABEL: test_basic:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    stp  x0, x30, [sp, #8]
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    str x1, [sp, #24]
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    bl some_call
; CHECK-NEXT:  .Ltmp18:
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:  # %bb.1: # %invoke_safepoint_normal_dest
; CHECK-NEXT:    ldr x0, [sp, #8]
; CHECK-NEXT:  .LBB0_2: # %invoke_safepoint_normal_dest
; CHECK-NEXT:    ldr x30, [sp, #16]
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_3: # %exceptional_return
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    ldr x0, [sp, #24]
; CHECK-NEXT:    b .LBB0_2
                                     i64 addrspace(1)* %obj1)
gc "statepoint-example" personality i32 ()* @"personality_function" {
entry:
  %0 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1)
          to label %invoke_safepoint_normal_dest unwind label %exceptional_return

invoke_safepoint_normal_dest:
  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 13, i32 13)
  %obj1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 14, i32 14)
  br label %normal_return

normal_return:
  ret i64 addrspace(1)* %obj.relocated

exceptional_return:
  %landing_pad = landingpad token
          cleanup
  %obj.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 13, i32 13)
  %obj1.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 14, i32 14)
  ret i64 addrspace(1)* %obj1.relocated1
}
; CHECK-LABEL: GCC_except_table{{[0-9]+}}:
; CHECK: .uleb128  .Ltmp{{[0-9]+}}-.Ltmp{{[0-9]+}}
; CHECK: .uleb128  .Ltmp{{[0-9]+}}-.Lfunc_begin{{[0-9]+}}
; CHECK: .byte  0
; CHECK: .p2align 2

define i64 addrspace(1)* @test_result(i64 addrspace(1)* %obj,
; CHECK-LABEL: test_result:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    str x30, [sp, #-16]!
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    str  x0, [sp, #8]
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    bl some_other_call
; CHECK-NEXT:  .Ltmp19:
; CHECK-NEXT:  .Ltmp4:
; CHECK-NEXT:  # %bb.1: # %normal_return
; CHECK-NEXT:    ldr x30, [sp], #16
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB1_2: # %exceptional_return
; CHECK-NEXT:  .Ltmp5:
; CHECK-NEXT:    ldr x0, [sp, #8]
; CHECK-NEXT:    ldr x30, [sp], #16
; CHECK-NEXT:    ret
                                      i64 addrspace(1)* %obj1)
  gc "statepoint-example" personality i32 ()* @personality_function {
entry:
  %0 = invoke token (i64, i32, i64 addrspace(1)* (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_p1i64p1i64f(i64 0, i32 0, i64 addrspace(1)* (i64 addrspace(1)*)* @some_other_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1)
          to label %normal_return unwind label %exceptional_return

normal_return:
  %ret_val = call i64 addrspace(1)* @llvm.experimental.gc.result.p1i64(token %0)
  ret i64 addrspace(1)* %ret_val

exceptional_return:
  %landing_pad = landingpad token
          cleanup
  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 13, i32 13)
  ret i64 addrspace(1)* %obj.relocated
}
; CHECK-LABEL: GCC_except_table{{[0-9]+}}:
; CHECK: .uleb128 .Ltmp{{[0-9]+}}-.Ltmp{{[0-9]+}}
; CHECK: .uleb128 .Ltmp{{[0-9]+}}-.Lfunc_begin{{[0-9]+}}
; CHECK: .byte 0
; CHECK: .p2align 2

define i64 addrspace(1)* @test_same_val(i1 %cond, i64 addrspace(1)* %val1, i64 addrspace(1)* %val2, i64 addrspace(1)* %val3)
; CHECK-LABEL: test_same_val:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    stp x19, x30, [sp, #16]
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w19, -16
; CHECK-NEXT:    mov w19, w0
; CHECK-NEXT:    tbz w0, #0, .LBB2_3
; CHECK-NEXT:  # %bb.1: # %left
; CHECK-NEXT:    stp x1, x2, [sp]
; CHECK-NEXT:  .Ltmp9:
; CHECK-NEXT:    mov x0, x1
; CHECK-NEXT:    bl some_call
; CHECK-NEXT:  .Ltmp20:
; CHECK-NEXT:  .Ltmp10:
; CHECK-NEXT:  # %bb.2: # %left.relocs
; CHECK-NEXT:    ldp x8, x9, [sp]
; CHECK-NEXT:    b .LBB2_5
; CHECK-NEXT:  .LBB2_3: # %right
; CHECK-NEXT:    stp x2, x3, [sp]
; CHECK-NEXT:  .Ltmp6:
; CHECK-NEXT:    mov x0, x1
; CHECK-NEXT:    bl some_call
; CHECK-NEXT:  .Ltmp21:
; CHECK-NEXT:  .Ltmp7:
; CHECK-NEXT:  # %bb.4: # %right.relocs
; CHECK-NEXT:    ldp x9, x8, [sp]
; CHECK-NEXT:  .LBB2_5: # %normal_return
; CHECK-NEXT:    tst w19, #0x1
; CHECK-NEXT:    csel x0, x8, x9, ne
; CHECK-NEXT:  .LBB2_6: # %normal_return
; CHECK-NEXT:    ldp  x19, x30, [sp, #16]
; CHECK-NEXT:    add  sp, sp, #32
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB2_9: # %exceptional_return.right
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:  .Ltmp8:
; CHECK-NEXT:    ldr x0, [sp]
; CHECK-NEXT:    b .LBB2_6
; CHECK-NEXT:  .LBB2_7: # %exceptional_return.left
; CHECK-NEXT:  .Ltmp11:
; CHECK-NEXT:    ldr x0, [sp]
; CHECK-NEXT:    b .LBB2_6
  gc "statepoint-example" personality i32 ()* @"personality_function" {
entry:
  br i1 %cond, label %left, label %right

left:
  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i64 addrspace(1)* %val1, i64 addrspace(1)* %val2)
           to label %left.relocs unwind label %exceptional_return.left

left.relocs:
  %val1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 13, i32 13)
  %val2.relocated_left = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 14, i32 14)
  br label %normal_return

right:
  %sp2 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i64 addrspace(1)* %val2, i64 addrspace(1)* %val3)
           to label %right.relocs unwind label %exceptional_return.right

right.relocs:
  %val2.relocated_right = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 13, i32 13)
  %val3.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 14, i32 14)
  br label %normal_return

normal_return:
  %a1 = phi i64 addrspace(1)* [%val1.relocated, %left.relocs], [%val3.relocated, %right.relocs]
  %a2 = phi i64 addrspace(1)* [%val2.relocated_left, %left.relocs], [%val2.relocated_right, %right.relocs]
  %ret = select i1 %cond, i64 addrspace(1)* %a1, i64 addrspace(1)* %a2
  ret i64 addrspace(1)* %ret

exceptional_return.left:
  %landing_pad = landingpad token
          cleanup
  %val.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 13, i32 13)
  ret i64 addrspace(1)* %val.relocated2

exceptional_return.right:
  %landing_pad1 = landingpad token
          cleanup
  %val.relocated3 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad1, i32 13, i32 13)
  ret i64 addrspace(1)* %val.relocated3
}

define i64 addrspace(1)* @test_null_undef(i64 addrspace(1)* %val1)
; CHECK-LABEL: test_null_undef:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    str x30, [sp, #-16]!
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:  .Ltmp12:
; CHECK-NEXT:    bl some_call
; CHECK-NEXT:  .Ltmp22:
; CHECK-NEXT:  .Ltmp13:
; CHECK-NEXT:  .LBB3_1: # %normal_return
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:    ldr x30, [sp], #16
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB3_2: # %exceptional_return
; CHECK-NEXT:  .Ltmp14:
; CHECK-NEXT:    b .LBB3_1
       gc "statepoint-example" personality i32 ()* @"personality_function" {
entry:
  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i64 addrspace(1)* null, i64 addrspace(1)* undef)
           to label %normal_return unwind label %exceptional_return

normal_return:
  %null.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 13, i32 13)
  %undef.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 14, i32 14)
  ret i64 addrspace(1)* %null.relocated

exceptional_return:
  %landing_pad = landingpad token
          cleanup
  %null.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 13, i32 13)
  %undef.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 14, i32 14)
  ret i64 addrspace(1)* %null.relocated2
}

define i64 addrspace(1)* @test_alloca_and_const(i64 addrspace(1)* %val1)
; CHECK-LABEL: test_alloca_and_const:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    str x30, [sp, #-16]!
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:  .Ltmp15:
; CHECK-NEXT:    bl some_call
; CHECK-NEXT:  .Ltmp23:
; CHECK-NEXT:  .Ltmp16:
; CHECK-NEXT:  # %bb.1: # %normal_return
; CHECK-NEXT:    add x0, sp, #12
; CHECK-NEXT:    ldr x30, [sp], #16
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB4_2: # %exceptional_return
; CHECK-NEXT:  .Ltmp17:
; CHECK-NEXT:    mov w0, #15
; CHECK-NEXT:    ldr x30, [sp], #16
; CHECK-NEXT:    ret
       gc "statepoint-example" personality i32 ()* @"personality_function" {
entry:
  %a = alloca i32
  %aa = addrspacecast i32* %a to i32 addrspace(1)*
  %c = inttoptr i64 15 to i64 addrspace(1)*
  %sp = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 5, i32 0, i32 -1, i32 0, i32 0, i32 0, i32 addrspace(1)* %aa, i64 addrspace(1)* %c)
           to label %normal_return unwind label %exceptional_return

normal_return:
  %aa.rel = call coldcc i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %sp, i32 13, i32 13)
  %aa.converted = bitcast i32 addrspace(1)* %aa.rel to i64 addrspace(1)*
  ret i64 addrspace(1)* %aa.converted

exceptional_return:
  %landing_pad = landingpad token
          cleanup
  %aa.rel2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 14, i32 14)
  ret i64 addrspace(1)* %aa.rel2
}

declare token @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...)
declare token @llvm.experimental.gc.statepoint.p0f_p1i64p1i64f(i64, i32, i64 addrspace(1)* (i64 addrspace(1)*)*, i32, i32, ...)

declare i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token, i32, i32)
declare i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token, i32, i32)
declare i64 addrspace(1)* @llvm.experimental.gc.result.p1i64(token)
